#!/usr/bin/env bash
#
# Homer — Autonomous agent loop powered by GitHub Issues + Claude Code
#
# Usage:
#   homer [OPTIONS]
#   homer plan <description>    Decompose feature into GitHub Issues
#   homer status                Show issue board
#   homer sync                  Unblock issues whose deps are met
#
# Options:
#   --repo OWNER/REPO     Target repo (default: auto-detect from git remote)
#   --tool claude|codex   Which AI CLI to invoke (default: claude)
#   --max-iterations N    Max issues to process before stopping (0 = unlimited)
#   --label LABEL         Custom label prefix (default: homer)
#   --dry-run             Show what would happen without doing it
#   -h, --help            Show this help
#
# Prerequisites:
#   - gh CLI (authenticated)
#   - claude CLI (or codex)
#   - git
#

set -euo pipefail

# ── Defaults ─────────────────────────────────────────────────────────────────

REPO=""
TOOL="claude"
MAX_ITERATIONS=0
LABEL_PREFIX="homer"
DRY_RUN=false
SUBCOMMAND=""
PLAN_DESCRIPTION=""
VERBOSE=false

# ── Colors ───────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
RESET='\033[0m'

log()  { echo -e "${CYAN}[homer]${RESET} $*"; }
warn() { echo -e "${YELLOW}[homer]${RESET} $*" >&2; }
err()  { echo -e "${RED}[homer]${RESET} $*" >&2; }
ok()   { echo -e "${GREEN}[homer]${RESET} $*"; }

# ── Argument parsing ─────────────────────────────────────────────────────────

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      plan|status|sync)
        SUBCOMMAND="$1"
        shift
        # Collect remaining as plan description
        if [[ "$SUBCOMMAND" == "plan" ]]; then
          PLAN_DESCRIPTION="$*"
          return
        fi
        ;;
      --repo)     REPO="${2:?--repo requires OWNER/REPO}"; shift 2 ;;
      --repo=*)   REPO="${1#*=}"; shift ;;
      --tool)     TOOL="${2:?--tool requires claude|codex}"; shift 2 ;;
      --tool=*)   TOOL="${1#*=}"; shift ;;
      --max-iterations) MAX_ITERATIONS="${2:?--max-iterations requires N}"; shift 2 ;;
      --max-iterations=*) MAX_ITERATIONS="${1#*=}"; shift ;;
      --label)    LABEL_PREFIX="${2:?--label requires prefix}"; shift 2 ;;
      --label=*)  LABEL_PREFIX="${1#*=}"; shift ;;
      --dry-run)  DRY_RUN=true; shift ;;
      --verbose|-v) VERBOSE=true; shift ;;
      -h|--help)  usage; exit 0 ;;
      *) err "Unknown argument: $1"; usage; exit 1 ;;
    esac
  done
}

usage() {
  cat <<'EOF'
Homer — Autonomous agent loop powered by GitHub Issues + Claude Code

USAGE:
  homer [OPTIONS]                    Start work loop
  homer plan <description>           Decompose feature into GitHub Issues
  homer status                       Show issue board
  homer sync                         Unblock issues whose deps are met

OPTIONS:
  --repo OWNER/REPO     Target repo (default: auto-detect)
  --tool claude|codex   AI CLI to use (default: claude)
  --max-iterations N    Max issues to process (0 = unlimited)
  --label PREFIX        Label prefix (default: homer)
  --dry-run             Preview without executing
  -v, --verbose         Verbose output
  -h, --help            This help

SETUP:
  1. gh auth login
  2. Install claude CLI (or codex)
  3. homer plan "Add user authentication"
  4. homer                              # starts working
  5. homer-watch                        # open another terminal for dashboard

MULTI-AGENT:
  # Terminal 1:
  homer --repo myorg/myapp

  # Terminal 2 (same repo):
  homer --repo myorg/myapp

  # Terminal 3 (dashboard):
  homer-watch --repo myorg/myapp

  Each Homer claims different issues. No collisions.
EOF
}

# ── Repo detection ───────────────────────────────────────────────────────────

detect_repo() {
  if [[ -n "$REPO" ]]; then return; fi

  if command -v gh &>/dev/null; then
    REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)
  fi

  if [[ -z "$REPO" ]]; then
    # Try git remote
    local url
    url=$(git remote get-url origin 2>/dev/null || true)
    if [[ "$url" =~ github\.com[:/]([^/]+/[^/.]+) ]]; then
      REPO="${BASH_REMATCH[1]}"
    fi
  fi

  if [[ -z "$REPO" ]]; then
    err "Could not detect repo. Use --repo OWNER/REPO"
    exit 1
  fi
}

# ── Preflight checks ────────────────────────────────────────────────────────

preflight() {
  local missing=()

  if ! command -v gh &>/dev/null; then missing+=("gh (GitHub CLI)"); fi
  if ! command -v git &>/dev/null; then missing+=("git"); fi
  if ! command -v "$TOOL" &>/dev/null; then missing+=("$TOOL"); fi
  if ! command -v jq &>/dev/null; then missing+=("jq"); fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    err "Missing required tools:"
    for t in "${missing[@]}"; do
      err "  - $t"
    done
    exit 1
  fi

  # Check gh auth
  if ! gh auth status &>/dev/null 2>&1; then
    err "gh is not authenticated. Run: gh auth login"
    exit 1
  fi
}

# ── GitHub Issue helpers ─────────────────────────────────────────────────────

# Fetch all homer-labeled issues as JSON
fetch_issues() {
  gh issue list \
    --repo "$REPO" \
    --label "$LABEL_PREFIX" \
    --state all \
    --json number,title,labels,state,body,updatedAt,comments \
    --limit 200 2>/dev/null || echo "[]"
}

# Get label names for an issue (from JSON)
get_labels() {
  echo "$1" | jq -r '.labels[]?.name // empty'
}

# Check if issue has a specific label
has_label() {
  local issue_json="$1" label="$2"
  echo "$issue_json" | jq -e --arg l "$label" '.labels[]? | select(.name == $l)' &>/dev/null
}

# Get priority number from labels (default 99)
get_priority() {
  local p
  p=$(echo "$1" | jq -r '.labels[]?.name // empty' | grep "^priority:" | head -1 | cut -d: -f2)
  echo "${p:-99}"
}

# Extract "Depends on: #X, #Y" from issue body
get_deps() {
  local body
  body=$(echo "$1" | jq -r '.body // ""')
  echo "$body" | grep -i "depends on:" | grep -oE '#[0-9]+' | tr -d '#' || true
}

# Check if all dependency issues are closed
deps_met() {
  local issue_json="$1"
  local deps
  deps=$(get_deps "$issue_json")

  if [[ -z "$deps" ]]; then
    return 0  # No deps = met
  fi

  for dep_num in $deps; do
    local dep_state
    dep_state=$(gh issue view "$dep_num" --repo "$REPO" --json state -q '.state' 2>/dev/null || echo "OPEN")
    if [[ "$dep_state" != "CLOSED" ]]; then
      return 1  # Dep not met
    fi
  done
  return 0  # All deps closed
}

# ── SUBCOMMAND: status ───────────────────────────────────────────────────────

cmd_status() {
  log "Issue board for ${BOLD}$REPO${RESET}"
  echo ""

  local issues
  issues=$(fetch_issues)

  local in_progress ready blocked done_issues failed
  in_progress=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:in-progress\")]")
  ready=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:ready\")]")
  blocked=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:blocked\")]")
  done_issues=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:done\" or .state == \"CLOSED\")]")
  failed=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:failed\")]")

  local total done_count
  total=$(echo "$issues" | jq 'length')
  done_count=$(echo "$done_issues" | jq 'length')

  # Progress bar
  if [[ "$total" -gt 0 ]]; then
    local pct=$((done_count * 100 / total))
    local bar_filled=$((pct / 2))
    local bar_empty=$((50 - bar_filled))
    printf "  ${GREEN}%s${RESET}%s %d/%d (%d%%)\n\n" \
      "$(printf '█%.0s' $(seq 1 $bar_filled 2>/dev/null) 2>/dev/null || true)" \
      "$(printf '░%.0s' $(seq 1 $bar_empty 2>/dev/null) 2>/dev/null || true)" \
      "$done_count" "$total" "$pct"
  fi

  # Print sections
  print_section "$YELLOW" "IN PROGRESS" "$in_progress"
  print_section "$GREEN" "READY" "$ready"
  print_section "$RED" "BLOCKED" "$blocked"
  print_section "$MAGENTA" "FAILED" "$failed"
  print_section "$DIM" "DONE" "$done_issues"
}

print_section() {
  local color="$1" title="$2" items="$3"
  local count
  count=$(echo "$items" | jq 'length')

  echo -e "${color}${BOLD}${title}${RESET} ${DIM}(${count})${RESET}"

  if [[ "$count" -eq 0 ]]; then
    echo -e "  ${DIM}(none)${RESET}"
  else
    echo "$items" | jq -r '.[] | "  #\(.number) [\((.labels[]?.name // "" | select(startswith("priority:")) // "P?"))] \(.title)"' 2>/dev/null || \
    echo "$items" | jq -r '.[] | "  #\(.number) \(.title)"'
  fi
  echo ""
}

# ── SUBCOMMAND: sync ─────────────────────────────────────────────────────────

cmd_sync() {
  log "Syncing blocked issues for ${BOLD}$REPO${RESET}..."

  local issues
  issues=$(fetch_issues)

  local blocked
  blocked=$(echo "$issues" | jq -c ".[] | select(.labels[]?.name == \"${LABEL_PREFIX}:blocked\")")

  local unblocked=0

  while IFS= read -r issue; do
    [[ -z "$issue" ]] && continue
    local num title
    num=$(echo "$issue" | jq -r '.number')
    title=$(echo "$issue" | jq -r '.title')

    if deps_met "$issue"; then
      ok "Unblocking #$num: $title"
      if [[ "$DRY_RUN" == false ]]; then
        gh issue edit "$num" --repo "$REPO" \
          --add-label "${LABEL_PREFIX}:ready" \
          --remove-label "${LABEL_PREFIX}:blocked" 2>/dev/null
      fi
      ((unblocked++))
    else
      log "#$num still blocked: $title"
    fi
  done <<< "$blocked"

  ok "Sync complete. Unblocked $unblocked issue(s)."
}

# ── SUBCOMMAND: plan ─────────────────────────────────────────────────────────

cmd_plan() {
  if [[ -z "$PLAN_DESCRIPTION" ]]; then
    err "Usage: homer plan <feature description>"
    err "Example: homer plan 'Add user authentication with OAuth'"
    exit 1
  fi

  log "Planning: ${BOLD}$PLAN_DESCRIPTION${RESET}"
  log "Using $TOOL to decompose into GitHub Issues..."

  local prompt
  prompt=$(cat <<PROMPT
You are Homer, an autonomous agent coordinator. Your job is to decompose a feature into GitHub Issues.

TARGET REPO: $REPO
FEATURE: $PLAN_DESCRIPTION

Create GitHub Issues by running \`gh issue create\` commands. Follow these rules:

1. Each issue must be completable in ONE Claude Code session (~30 min of focused work)
2. Order by dependency: schema/data before backend before frontend
3. Independent issues get the same priority number (they can run in parallel)
4. Every issue body must follow this format:

\`\`\`
## Story
As a [user], I want [feature] so that [benefit].

## Acceptance Criteria
- [ ] Specific verifiable criterion 1
- [ ] Specific verifiable criterion 2
- [ ] Lint/typecheck passes

## Dependencies
Depends on: #X, #Y (or "None")

## Notes
Implementation hints, file references, context.
\`\`\`

5. Labels for each issue: \`${LABEL_PREFIX}\` + \`priority:N\` + either \`${LABEL_PREFIX}:ready\` (no deps) or \`${LABEL_PREFIX}:blocked\` (has deps)
6. Create the labels first if they don't exist

IMPORTANT:
- Do NOT create issues that are too big. Split aggressively.
- Use \`gh issue create --repo $REPO --title "..." --body "..." --label "${LABEL_PREFIX},${LABEL_PREFIX}:ready,priority:1"\`
- After creating all issues, update blocked issues to reference the actual created issue numbers
- Print a summary showing the dependency graph at the end

Execute now. Create the issues.
PROMPT
)

  if [[ "$DRY_RUN" == true ]]; then
    log "DRY RUN — would send this prompt to $TOOL:"
    echo "$prompt"
    return
  fi

  # Ensure labels exist
  ensure_labels

  # Call the AI tool with the planning prompt
  case "$TOOL" in
    claude)
      echo "$prompt" | claude --dangerously-skip-permissions --print 2>/dev/null || \
      echo "$prompt" | claude -p 2>/dev/null || {
        err "Failed to invoke claude CLI"
        exit 1
      }
      ;;
    codex)
      echo "$prompt" | codex --quiet 2>/dev/null || {
        err "Failed to invoke codex CLI"
        exit 1
      }
      ;;
    *)
      err "Unknown tool: $TOOL"
      exit 1
      ;;
  esac

  ok "Plan created. Run 'homer status' to see the board."
}

# ── Label management ─────────────────────────────────────────────────────────

ensure_labels() {
  local labels=(
    "${LABEL_PREFIX}:Homer managed issue:0969da"
    "${LABEL_PREFIX}:ready:0e8a16"
    "${LABEL_PREFIX}:in-progress:fbca04"
    "${LABEL_PREFIX}:blocked:d93f0b"
    "${LABEL_PREFIX}:done:1d7a28"
    "${LABEL_PREFIX}:failed:b60205"
    "priority:1:ff0000"
    "priority:2:ff6600"
    "priority:3:ffcc00"
    "priority:4:66cc00"
    "priority:5:00cc00"
  )

  for entry in "${labels[@]}"; do
    local name desc color
    name=$(echo "$entry" | cut -d: -f1-2)
    desc=$(echo "$entry" | cut -d: -f3- | cut -d: -f1)
    color=$(echo "$entry" | rev | cut -d: -f1 | rev)

    # Handle labels with descriptions vs without
    if [[ "$desc" == "$color" ]]; then
      desc=""
    fi

    gh label create "$name" \
      --repo "$REPO" \
      --color "$color" \
      --description "$desc" \
      --force 2>/dev/null || true
  done
}

# ── Main work loop ───────────────────────────────────────────────────────────

cmd_work() {
  log "Starting Homer work loop on ${BOLD}$REPO${RESET}"
  log "Tool: ${BOLD}$TOOL${RESET}  Max iterations: ${BOLD}${MAX_ITERATIONS:-unlimited}${RESET}"
  echo ""

  local iteration=0
  local session_id
  session_id="homer-$(date +%s)-$$"

  while true; do
    ((iteration++))

    if [[ "$MAX_ITERATIONS" -gt 0 && "$iteration" -gt "$MAX_ITERATIONS" ]]; then
      ok "Reached max iterations ($MAX_ITERATIONS). Stopping."
      break
    fi

    log "─── Iteration $iteration ───"

    # 1. Sync blocked issues first
    cmd_sync 2>/dev/null

    # 2. Find next ready issue
    local issues
    issues=$(fetch_issues)

    local ready_issues
    ready_issues=$(echo "$issues" | jq -c "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:ready\")]")
    local ready_count
    ready_count=$(echo "$ready_issues" | jq 'length')

    if [[ "$ready_count" -eq 0 ]]; then
      # Check if anything is still in-progress
      local ip_count
      ip_count=$(echo "$issues" | jq "[.[] | select(.labels[]?.name == \"${LABEL_PREFIX}:in-progress\")] | length")

      if [[ "$ip_count" -gt 0 ]]; then
        log "No ready issues, but $ip_count in progress. Waiting 30s..."
        sleep 30
        continue
      fi

      ok "No more work. All issues are done or blocked."
      break
    fi

    # Pick the highest priority (lowest number) ready issue whose deps are met
    local picked=""
    local pick_num="" pick_title="" pick_body=""

    # Sort by priority, then by issue number
    local sorted
    sorted=$(echo "$ready_issues" | jq -c 'sort_by((.labels[]?.name // "" | select(startswith("priority:")) | split(":")[1] | tonumber) // 99, .number) | .[]')

    while IFS= read -r candidate; do
      [[ -z "$candidate" ]] && continue

      if deps_met "$candidate"; then
        picked="$candidate"
        pick_num=$(echo "$picked" | jq -r '.number')
        pick_title=$(echo "$picked" | jq -r '.title')
        pick_body=$(echo "$picked" | jq -r '.body // ""')
        break
      fi
    done <<< "$sorted"

    if [[ -z "$picked" ]]; then
      log "All ready issues have unmet dependencies. Waiting 30s..."
      sleep 30
      continue
    fi

    log "Claiming ${BOLD}#$pick_num${RESET}: $pick_title"

    # 3. Claim the issue
    if [[ "$DRY_RUN" == false ]]; then
      gh issue edit "$pick_num" --repo "$REPO" \
        --add-label "${LABEL_PREFIX}:in-progress" \
        --remove-label "${LABEL_PREFIX}:ready" 2>/dev/null

      gh issue comment "$pick_num" --repo "$REPO" \
        --body "Homer session \`$session_id\` started at $(date -u +%Y-%m-%dT%H:%M:%SZ) (iteration $iteration)" 2>/dev/null
    fi

    # 4. Build the prompt for the AI tool
    local work_prompt
    work_prompt=$(cat <<WORK
You are working on GitHub Issue #$pick_num from repo $REPO.

TITLE: $pick_title

ISSUE BODY:
$pick_body

INSTRUCTIONS:
1. Read the acceptance criteria carefully
2. Implement each criterion, committing after each meaningful chunk
3. Run lint/typecheck/tests as specified in acceptance criteria
4. When ALL criteria are met, output exactly: HOMER_DONE
5. If you are stuck and cannot proceed, output exactly: HOMER_BLOCKED followed by a description of what's blocking you

Do not ask questions. Make reasonable decisions and implement.
WORK
)

    # 5. Run the AI tool
    local result_file
    result_file=$(mktemp /tmp/homer-result-XXXXXX)

    log "Running $TOOL on #$pick_num..."

    if [[ "$DRY_RUN" == true ]]; then
      log "DRY RUN — would invoke $TOOL with prompt for #$pick_num"
      echo "HOMER_DONE" > "$result_file"
    else
      case "$TOOL" in
        claude)
          echo "$work_prompt" | claude --dangerously-skip-permissions --print 2>/dev/null > "$result_file" || \
          echo "$work_prompt" | claude -p 2>/dev/null > "$result_file" || {
            warn "Claude invocation failed for #$pick_num"
            echo "HOMER_BLOCKED: Claude CLI failed" > "$result_file"
          }
          ;;
        codex)
          echo "$work_prompt" | codex --quiet 2>/dev/null > "$result_file" || {
            warn "Codex invocation failed for #$pick_num"
            echo "HOMER_BLOCKED: Codex CLI failed" > "$result_file"
          }
          ;;
      esac
    fi

    local result
    result=$(cat "$result_file")
    rm -f "$result_file"

    # 6. Parse result and update issue
    if echo "$result" | grep -q "HOMER_DONE"; then
      ok "#$pick_num completed!"

      if [[ "$DRY_RUN" == false ]]; then
        # Extract summary (last 20 lines before HOMER_DONE)
        local summary
        summary=$(echo "$result" | tail -30 | head -20)

        gh issue comment "$pick_num" --repo "$REPO" \
          --body "$(cat <<COMMENT
Homer session \`$session_id\` completed (iteration $iteration).

<details>
<summary>Session output</summary>

\`\`\`
$summary
\`\`\`

</details>
COMMENT
)" 2>/dev/null

        gh issue edit "$pick_num" --repo "$REPO" \
          --add-label "${LABEL_PREFIX}:done" \
          --remove-label "${LABEL_PREFIX}:in-progress" 2>/dev/null

        gh issue close "$pick_num" --repo "$REPO" 2>/dev/null
      fi

    elif echo "$result" | grep -q "HOMER_BLOCKED"; then
      local blocker
      blocker=$(echo "$result" | grep "HOMER_BLOCKED" | sed 's/HOMER_BLOCKED[: ]*//')
      warn "#$pick_num blocked: $blocker"

      if [[ "$DRY_RUN" == false ]]; then
        gh issue comment "$pick_num" --repo "$REPO" \
          --body "Homer session \`$session_id\` blocked (iteration $iteration): $blocker" 2>/dev/null

        gh issue edit "$pick_num" --repo "$REPO" \
          --add-label "${LABEL_PREFIX}:failed" \
          --remove-label "${LABEL_PREFIX}:in-progress" 2>/dev/null
      fi

    else
      warn "#$pick_num finished without clear signal. Marking for review."

      if [[ "$DRY_RUN" == false ]]; then
        local tail_output
        tail_output=$(echo "$result" | tail -20)

        gh issue comment "$pick_num" --repo "$REPO" \
          --body "Homer session \`$session_id\` finished without HOMER_DONE/HOMER_BLOCKED (iteration $iteration). Manual review needed.

\`\`\`
$tail_output
\`\`\`" 2>/dev/null

        gh issue edit "$pick_num" --repo "$REPO" \
          --add-label "${LABEL_PREFIX}:failed" \
          --remove-label "${LABEL_PREFIX}:in-progress" 2>/dev/null
      fi
    fi

    log ""
  done

  ok "Homer session $session_id finished after $iteration iteration(s)."
}

# ── Main ─────────────────────────────────────────────────────────────────────

main() {
  parse_args "$@"
  preflight
  detect_repo

  case "$SUBCOMMAND" in
    plan)   cmd_plan ;;
    status) cmd_status ;;
    sync)   cmd_sync ;;
    "")     cmd_work ;;
    *)      err "Unknown command: $SUBCOMMAND"; usage; exit 1 ;;
  esac
}

main "$@"
